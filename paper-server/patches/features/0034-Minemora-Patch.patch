From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tehin <62246450+Tehin@users.noreply.github.com>
Date: Wed, 2 Apr 2025 22:23:25 -0500
Subject: [PATCH] Minemora Patch


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 6ce4a98e4d3b633e3c87944c23b6b3f0ff58f159..6fcf25398d29f161a0769b4e9881fd4b5b4cf9f9 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -68,6 +68,9 @@ public final class ChunkHolderManager {
     public static final int ENTITY_TICKING_TICKET_LEVEL = ChunkLevel.ENTITY_TICKING_LEVEL;
     public static final int MAX_TICKET_LEVEL = ChunkLevel.MAX_LEVEL; // inclusive
 
+    // MoraPaper - Limit chunk unloads per tick
+    private static final int MAX_CHUNK_UNLOADS_PER_TICK = 180;
+
     public static final TicketType UNLOAD_COOLDOWN = ChunkSystemTicketType.create("chunk_system:unload_cooldown", null, 5L * 20L);
 
     private static final long NO_TIMEOUT_MARKER = Long.MIN_VALUE;
@@ -1194,7 +1197,9 @@ public final class ChunkHolderManager {
         // We do need to process updates here so that any addTicket that is synchronised before this call does not go missed.
         this.processTicketUpdates();
 
-        final int toUnloadCount = Math.max(50, (int)(unloadCountTentative * 0.05));
+        // MoraPaper - Limit chunk unload to prevent RAM overuse
+        final int toUnloadCount = Math.max(50,Math.min(MAX_CHUNK_UNLOADS_PER_TICK, (int) (unloadCountTentative * 0.05)));
+
         int processedCount = 0;
 
         for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
diff --git a/net/minecraft/network/chat/OutgoingChatMessage.java b/net/minecraft/network/chat/OutgoingChatMessage.java
index 4635182c73f28f63ba84982cb6bcb422221b738e..eb40e9b8051c7e159146104383a747d1c3c26566 100644
--- a/net/minecraft/network/chat/OutgoingChatMessage.java
+++ b/net/minecraft/network/chat/OutgoingChatMessage.java
@@ -26,6 +26,9 @@ public interface OutgoingChatMessage {
             this.sendToPlayer(player, filtered, boundType, null);
         }
         public void sendToPlayer(ServerPlayer player, boolean filtered, ChatType.Bound boundType, @javax.annotation.Nullable Component unsigned) {
+            // MoraPaper
+            if (player.chatDisabled) return;
+
             player.connection.sendDisguisedChatMessage(unsigned != null ? unsigned : this.content, boundType);
             // Paper end
         }
@@ -43,6 +46,9 @@ public interface OutgoingChatMessage {
             this.sendToPlayer(player, filtered, boundType, null);
         }
         public void sendToPlayer(ServerPlayer player, boolean filtered, ChatType.Bound boundType, @javax.annotation.Nullable Component unsigned) {
+            // MoraPaper
+            if (player.chatDisabled) return;
+
             // Paper end
             PlayerChatMessage playerChatMessage = this.message.filter(filtered);
             playerChatMessage = unsigned != null ? playerChatMessage.withUnsignedContent(unsigned) : playerChatMessage; // Paper
diff --git a/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java b/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java
index d13d67a3925f96a2a27159d303e8c19478971bd7..6b4dde35e530c964aa605f0f64e00c6a24ceb474 100644
--- a/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java
+++ b/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java
@@ -228,7 +228,7 @@ public class ClientboundPlayerInfoUpdatePacket implements Packet<ClientGamePacke
                 player.getUUID(),
                 player.getGameProfile(),
                 listed, // Paper - Add Listing API for Player
-                player.connection.latency(),
+                player.connection == null ? player.fakePing : player.connection.latency(),
                 player.gameMode(),
                 player.getTabListDisplayName(),
                 player.isModelPartShown(PlayerModelPart.HAT),
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index 52fa5112cd90ba766c94512a02401dd3aee82cc9..005e2e8d9bb946e766c2775b540ba813e94bbeee 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -1661,14 +1661,14 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
         // Paper start - optimise Folia entity scheduler
-        ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler)org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
-        for (io.papermc.paper.threadedregions.EntityScheduler scheduler : this.entitySchedulerTickList.getAllSchedulers()) {
-            if (scheduler.isRetired()) {
-                continue;
-            }
-
-            scheduler.executeTick();
-        }
+        // ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler)org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
+        // for (io.papermc.paper.threadedregions.EntityScheduler scheduler : this.entitySchedulerTickList.getAllSchedulers()) {
+        //     if (scheduler.isRetired()) {
+        //         continue;
+        //     }
+
+        //     scheduler.executeTick();
+        // }
         // Paper end - optimise Folia entity scheduler
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         profilerFiller.push("commandFunctions");
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index eb352aa4296abc3ed4cf31c590bc0be66daf4de3..555b2a0612306be07efde1fb2ba7a85c9b6b4c16 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1176,11 +1176,16 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
+                // MoraPaper - Iterate in the set itself not by creating a completely new arraylist
+                final java.util.Iterator<net.minecraft.server.network.ServerPlayerConnection> seenByIterator = this.seenBy.iterator();
+
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                while (seenByIterator.hasNext()) {
+                    final ServerPlayerConnection conn = seenByIterator.next();
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
-                        this.removePlayer(player);
+                        seenByIterator.remove();
+                        this.forceRemovePlayerPairing(player);
                     }
                 }
             }
@@ -1278,6 +1283,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
         }
 
+        // MoraSpigot - Remove the player without removing or checking for the seenBy, to prevent CME
+        // when the player is removed while in a loop
+        public void forceRemovePlayerPairing(ServerPlayer player) {
+            this.serverEntity.removePairing(player);
+        }
+
         public void updatePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (player != this.entity) {
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 2882cd829d4d8e1f8615f085f6908efcdf68ac62..caee337cd7e2759c1c1c65527f28553e4320f6f9 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -82,6 +82,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     public int getFullChunksCount() {
         return this.fullChunks.size();
     }
+
     long chunkFutureAwaitCounter;
     // Paper end
     // Paper start - rewrite chunk system
@@ -102,7 +103,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     private ChunkAccess syncLoad(final int chunkX, final int chunkZ, final ChunkStatus toStatus) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler();
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler();
         final CompletableFuture<ChunkAccess> completable = new CompletableFuture<>();
         chunkTaskScheduler.scheduleChunkLoad(
             chunkX, chunkZ, toStatus, true, ca.spottedleaf.concurrentutil.util.Priority.BLOCKING,
@@ -130,9 +131,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         return ret;
     }
 
-    private ChunkAccess getChunkFallback(final int chunkX, final int chunkZ, final ChunkStatus toStatus,
-                                         final boolean load) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler();
+    private ChunkAccess getChunkFallback(
+        final int chunkX, final int chunkZ, final ChunkStatus toStatus,
+        final boolean load
+    ) {
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler();
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager chunkHolderManager = chunkTaskScheduler.chunkHolderManager;
 
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder currentChunk = chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ));
@@ -154,16 +157,18 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         return load ? this.syncLoad(chunkX, chunkZ, toStatus) : null;
     }
+
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration optimisations
     private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom shuffleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(0L);
+
     private void iterateTickingChunksFaster() {
         final ServerLevel world = this.level;
         final int randomTickSpeed = world.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
 
         // TODO check on update: impl of forEachBlockTickingChunk will only iterate ENTITY ticking chunks!
         // TODO check on update: consumer just runs tickChunk
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getEntityTickingChunks();
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) world).moonrise$getEntityTickingChunks();
 
         // note: we can use the backing array here because:
         // 1. we do not care about new additions
@@ -177,7 +182,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
             // call mid-tick tasks for chunk system
             if ((i & 7) == 0) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.level.getServer()).moonrise$executeMidTickTasks();
+                ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer) this.level.getServer()).moonrise$executeMidTickTasks();
                 continue;
             }
         }
@@ -207,7 +212,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         try {
             FileUtil.createDirectoriesSafe(path);
         } catch (IOException var15) {
-            LOGGER.error("Failed to create dimension data storage directory", (Throwable)var15);
+            LOGGER.error("Failed to create dimension data storage directory", (Throwable) var15);
         }
 
         this.dataStorage = new DimensionDataStorage(new SavedData.Context(level), path, fixerUpper, level.registryAccess());
@@ -343,7 +348,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             return ret;
         }
 
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler()
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler()
             .chunkHolderManager.getChunkHolder(chunkX, chunkZ);
         if (holder == null) {
             return ret;
@@ -369,7 +374,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             chunkFutureMainThread = CompletableFuture.<CompletableFuture<ChunkResult<ChunkAccess>>>supplyAsync(
                     () -> this.getChunkFutureMainThread(x, z, chunkStatus, requireChunk), this.mainThreadProcessor
                 )
-                .thenCompose(future -> (CompletionStage<ChunkResult<ChunkAccess>>)future);
+                .thenCompose(future -> (CompletionStage<ChunkResult<ChunkAccess>>) future);
         }
 
         return chunkFutureMainThread;
@@ -380,7 +385,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, x, z, "Scheduling chunk load off-main");
 
         final int minLevel = ChunkLevel.byStatus(chunkStatus);
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(x, z);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(x, z);
 
         final boolean needsFullScheduling = chunkStatus == ChunkStatus.FULL && (chunkHolder == null || !chunkHolder.getChunkStatus().isOrAfter(FullChunkStatus.FULL));
 
@@ -400,7 +405,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 }
             };
 
-            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().scheduleChunkLoad(
+            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().scheduleChunkLoad(
                 x, z, chunkStatus, true,
                 ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
                 complete
@@ -423,7 +428,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     @Override
     public LightChunk getChunkForLighting(int chunkX, int chunkZ) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkX, chunkZ);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkX, chunkZ);
         if (newChunkHolder == null) {
             return null;
         }
@@ -441,12 +446,12 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     public boolean runDistanceManagerUpdates() {
-        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
+        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
     }
 
     public boolean isPositionTicking(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
         return newChunkHolder != null && newChunkHolder.isTickingReady();
         // Paper end - rewrite chunk system
     }
@@ -466,7 +471,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         // CraftBukkit end
         // Paper - rewrite chunk system
         this.dataStorage.close();
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.close(save, true); // Paper - rewrite chunk system
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.close(save, true); // Paper - rewrite chunk system
     }
 
     // CraftBukkit start - modelled on below
@@ -495,7 +500,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         this.runDistanceManagerUpdates();
         profilerFiller.popPush("chunks");
         if (tickChunks) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
+            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
             this.tickChunks();
             this.chunkMap.tick();
         }
@@ -538,7 +543,23 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         profiler.pop();
     }
 
+    // MoraPaper - Only do chunk mob spawning each 5 ticks instead of every tick
+    private final static int SPAWN_UPDATE_INTERVAL = 5;
+
+    // MoraPaper - The last time we ticked mob spawning
+    private int ticksSinceLastSpawnUpdate = 0;
+
     private void tickChunks(ProfilerFiller profiler, long timeInhabited) {
+        ticksSinceLastSpawnUpdate++;
+
+        // MoraPaper - Tick without the mob spawning between the interval
+        if (ticksSinceLastSpawnUpdate <= SPAWN_UPDATE_INTERVAL) {
+            iterateTickingChunksFaster();
+            return;
+        }
+
+        ticksSinceLastSpawnUpdate = 0;
+
         profiler.popPush("naturalSpawnCount");
         int naturalSpawnChunkCount = this.distanceManager.getNaturalSpawnChunkCount();
         // Paper start - Optional per player mob spawns
@@ -591,7 +612,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             profiler.popPush("shuffleSpawningChunks");
             // Paper start - chunk tick iteration optimisation
             this.shuffleRandom.setSeed(this.level.random.nextLong());
-            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
+            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns)
+                Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
             // Paper end - chunk tick iteration optimisation
             profiler.popPush("tickSpawningChunks");
 
@@ -619,12 +641,21 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         }
 
         if (!spawnCategories.isEmpty()) {
-            if (this.level.getWorldBorder().isWithinBounds(pos)) { // Paper - rewrite chunk system
+            if (this.level.getWorldBorder().isWithinBounds(pos) && !isInNoNaturalSpawnRadius(pos)) { // Paper - rewrite chunk system
                 NaturalSpawner.spawnForChunk(this.level, chunk, spawnState, spawnCategories);
             }
         }
     }
 
+    // MoraPaper Start - Limit natural spawn radius
+    public static boolean isInNoNaturalSpawnRadius(ChunkPos pos) {
+        int radius = 10; //TODO from config
+        int x = pos.x;
+        int z = pos.z;
+        return x >= -radius && x < radius && z >= -radius && z < radius;
+    }
+    // MoraPaper End
+
     private void getFullChunk(long chunkPos, Consumer<LevelChunk> fullChunkGetter) {
         // Paper start - rewrite chunk system
         // note: bypass currentlyLoaded from getChunkNow
diff --git a/net/minecraft/server/level/ServerEntity.java b/net/minecraft/server/level/ServerEntity.java
index e96d4dee14c05f2fa329bfb1588ec795d4e3d730..f820e0ba29c60cf738e0faa809fc1e83d95254f9 100644
--- a/net/minecraft/server/level/ServerEntity.java
+++ b/net/minecraft/server/level/ServerEntity.java
@@ -435,4 +435,5 @@ public class ServerEntity {
             ((ServerPlayer)this.entity).connection.send(packet);
         }
     }
+
 }
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index dda8d38ef61672cc714d9e5a475f9b0412ed5ff9..f037ba03e718b2b50b07d802619ab23b4a90b256 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -177,7 +177,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList<>(); // MoraPaper - Use CopyOnWriteArrayList for safe async loops
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
@@ -565,6 +565,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
     // Paper end - chunk tick iteration
 
+    // MoraPaper - Get async entities from our tick list (calculated in another thread)
+    public java.util.concurrent.ConcurrentLinkedQueue<Entity> getEntitiesAsync() {
+        return entityTickList.getEntitiesAsync();
+    }
+
     public ServerLevel(
         MinecraftServer server,
         Executor dispatcher,
@@ -675,6 +680,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.chunkDataController = new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.ChunkDataController((ServerLevel)(Object)this, this.chunkTaskScheduler);
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
+        // MoraPaper
+        net.minemora.MoraPaper.startNearestPlayerUpdater(this);
     }
 
     // Paper start
@@ -836,9 +843,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         if (this.tickTime) {
             long l = this.levelData.getGameTime() + 1L;
             this.serverLevelData.setGameTime(l);
-            Profiler.get().push("scheduledFunctions");
             this.serverLevelData.getScheduledEvents().tick(this.server, l);
-            Profiler.get().pop();
             if (this.serverLevelData.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
                 this.setDayTime(this.levelData.getDayTime() + 1L);
             }
@@ -917,8 +922,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         ChunkPos pos = chunk.getPos();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("iceandsnow");
 
         if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
         for (int i = 0; i < randomTickSpeed; i++) {
@@ -928,12 +931,9 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         }
         } // Paper - Option to disable ice and snow
 
-        profilerFiller.popPush("tickBlocks");
         if (randomTickSpeed > 0) {
             this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
         }
-
-        profilerFiller.pop();
     }
 
     public void tickThunder(LevelChunk chunk) {
@@ -941,15 +941,14 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         boolean isRaining = this.isRaining();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("thunder");
         if (!this.paperConfig().environment.disableThunder && isRaining && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
             BlockPos blockPos = this.findLightningTargetAround(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             if (this.isRainingAt(blockPos)) {
                 DifficultyInstance currentDifficultyAt = this.getCurrentDifficultyAt(blockPos);
                 boolean flag = this.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)
                     && this.random.nextDouble() < currentDifficultyAt.getEffectiveDifficulty() * this.paperConfig().entities.spawning.skeletonHorseThunderSpawnChance.or(0.01) // Paper - Configurable spawn chances for skeleton horses
-                    && !this.getBlockState(blockPos.below()).is(Blocks.LIGHTNING_ROD);
+                    && !this.getBlockState(blockPos.below()).is(Blocks.LIGHTNING_ROD)
+                    && !ServerChunkCache.isInNoNaturalSpawnRadius(pos);
                 if (flag) {
                     SkeletonHorse skeletonHorse = EntityType.SKELETON_HORSE.create(this, EntitySpawnReason.EVENT);
                     if (skeletonHorse != null) {
@@ -968,8 +967,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 }
             }
         }
-
-        profilerFiller.pop();
     }
 
     @VisibleForTesting
@@ -1267,17 +1264,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             }
             // Paper end - log detailed entity tick information
         entity.setOldPosAndRot();
-        ProfilerFiller profilerFiller = Profiler.get();
         entity.tickCount++;
         entity.totalEntityAge++; // Paper - age-like counter for all entities
-        profilerFiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType()).toString());
-        profilerFiller.incrementCounter("tickNonPassenger");
         final boolean isActive = io.papermc.paper.entity.activation.ActivationRange.checkIfActive(entity); // Paper - EAR 2
         if (isActive) { // Paper - EAR 2
         entity.tick();
         entity.postTick(); // CraftBukkit
         } else {entity.inactiveTick();} // Paper - EAR 2
-        profilerFiller.pop();
 
         for (Entity entity1 : entity.getPassengers()) {
             this.tickPassenger(entity, entity1, isActive); // Paper - EAR 2
@@ -1298,9 +1291,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             passengerEntity.setOldPosAndRot();
             passengerEntity.tickCount++;
             passengerEntity.totalEntityAge++; // Paper - age-like counter for all entities
-            ProfilerFiller profilerFiller = Profiler.get();
-            profilerFiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(passengerEntity.getType()).toString());
-            profilerFiller.incrementCounter("tickPassenger");
             // Paper start - EAR 2
             if (isActive) {
             passengerEntity.rideTick();
@@ -1312,7 +1302,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 ridingEntity.positionRider(passengerEntity);
             }
             // Paper end - EAR 2
-            profilerFiller.pop();
 
             for (Entity entity : passengerEntity.getPassengers()) {
                 this.tickPassenger(passengerEntity, entity, isActive); // Paper - EAR 2
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index 728fa1210e0fd837e28c48802045dea2ae59f5d6..5871122ddfbc63e4c0cb9ddb13a698f85d9bff38 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -222,6 +222,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
     public final ServerPlayerGameMode gameMode;
     private final PlayerAdvancements advancements;
     private final ServerStatsCounter stats;
+    public int fakePing;
     private float lastRecordedHealthAndAbsorption = Float.MIN_VALUE;
     private int lastRecordedFoodLevel = Integer.MIN_VALUE;
     private int lastRecordedAirLevel = Integer.MIN_VALUE;
@@ -544,6 +545,23 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         // CraftBukkit end
     }
 
+    // MoraPaper - optimized constructor for NPCs
+    public ServerPlayer(MinecraftServer server, ServerLevel level, GameProfile gameProfile) {
+        super(level, gameProfile);
+        this.textFilter = server.createTextFilterForPlayer(this);
+        this.gameMode = server.createGameModeForPlayer(this);
+        this.server = server;
+        this.object = null;
+        // CraftBukkit start
+        this.displayName = this.getScoreboardName();
+        this.adventure$displayName = net.kyori.adventure.text.Component.text(this.getScoreboardName()); // Paper
+        this.bukkitPickUpLoot = true;
+        this.maxHealthCache = this.getMaxHealth();
+        this.recipeBook = null;
+        this.stats = null;
+        this.advancements = null;
+    }
+
     @Override
     public BlockPos adjustSpawnLocation(ServerLevel level, BlockPos pos) {
         AABB aabb = this.getDimensions(Pose.STANDING).makeBoundingBox(Vec3.ZERO);
@@ -2267,7 +2285,12 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.sendSystemMessage(mesage, false);
     }
 
+    // MoraPaper - Completely disable chat
+    public boolean chatDisabled = false;
+
     public void sendSystemMessage(Component message, boolean overlay) {
+        if (chatDisabled) return;
+
         if (this.acceptsSystemMessages(overlay)) {
             this.connection
                 .send(
@@ -2295,6 +2318,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.sendChatMessage(message, filtered, boundType, null);
     }
     public void sendChatMessage(OutgoingChatMessage message, boolean filtered, ChatType.Bound boundType, @Nullable Component unsigned) {
+        // MoraPaper
+        if (chatDisabled) return;
+
         // Paper end
         if (this.acceptsChatMessages()) {
             message.sendToPlayer(this, filtered, boundType, unsigned); // Paper
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 625eae18ab13ae27949128f6325b3608a557cf1f..49fbd505bed985e94df6693892422537758f164e 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -2447,8 +2447,9 @@ public class ServerGamePacketListenerImpl
                 LastSeenMessages lastSeenMessages = this.lastSeenMessages.applyUpdate(update);
                 var10000 = Optional.of(lastSeenMessages);
             } catch (LastSeenMessagesValidator.ValidationException var5) {
-                LOGGER.error("Failed to validate message acknowledgements from {}: {}", this.player.getName().getString(), var5.getMessage());
-                this.disconnectAsync(CHAT_VALIDATION_FAILED, org.bukkit.event.player.PlayerKickEvent.Cause.CHAT_VALIDATION_FAILED); // Paper - kick event causes & add proper async disconnect
+                // MoraPaper - Ignore kicks for invalid messages
+                // LOGGER.error("Failed to validate message acknowledgements from {}: {}", this.player.getName().getString(), var5.getMessage());
+                // this.disconnectAsync(CHAT_VALIDATION_FAILED, org.bukkit.event.player.PlayerKickEvent.Cause.CHAT_VALIDATION_FAILED); // Paper - kick event causes & add proper async disconnect
                 return Optional.empty();
             }
 
@@ -2550,8 +2551,9 @@ public class ServerGamePacketListenerImpl
             try {
                 this.lastSeenMessages.applyOffset(packet.offset());
             } catch (LastSeenMessagesValidator.ValidationException var5) {
-                LOGGER.error("Failed to validate message acknowledgement offset from {}: {}", this.player.getName().getString(), var5.getMessage());
-                this.disconnectAsync(ServerGamePacketListenerImpl.CHAT_VALIDATION_FAILED, org.bukkit.event.player.PlayerKickEvent.Cause.CHAT_VALIDATION_FAILED); // Paper - kick event causes & add proper async disconnect
+                // MoraPaper - Ignore kicks for invalid messages
+                // LOGGER.error("Failed to validate message acknowledgement offset from {}: {}", this.player.getName().getString(), var5.getMessage());
+                // this.disconnectAsync(ServerGamePacketListenerImpl.CHAT_VALIDATION_FAILED, org.bukkit.event.player.PlayerKickEvent.Cause.CHAT_VALIDATION_FAILED); // Paper - kick event causes & add proper async disconnect
             }
         }
     }
@@ -2666,6 +2668,10 @@ public class ServerGamePacketListenerImpl
             return;
         }
         // CraftBukkit end
+
+        // MoraPaper
+        if (player.chatDisabled) return;
+
         // Paper start - Ensure that client receives chat packets in the same order that we add into the message signature cache
         synchronized (this.messageSignatureCache) {
         this.send(
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index 1ba342a1a60951f828034d3ed535b577b3990bf6..3e0be34a51460ebd033ab946ab43daf1553b1cb9 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -4661,4 +4661,9 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
 
     public record Fallsounds(SoundEvent small, SoundEvent big) {
     }
+
+    // MoraPaper start - LivingEntity equipment accessor
+    public EntityEquipment getEquipment() {
+        return this.equipment;
+    }
 }
diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index 0470c4bbf8be7e48ce8dfa4910c3b9f5ebb23360..5f25e6ce94739ff07eee3b90959d4917a36cc204 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -499,8 +499,13 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         this.resetAngularLeashMomentum();
     }
 
+    // MoraPaper
+    public static int distanceSqrToDisableAi = 400;
+
     @Override
     public void aiStep() {
+        if(nearestPlayerData.distanceSqr > distanceSqrToDisableAi) return;
+
         super.aiStep();
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("looting");
@@ -695,21 +700,39 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         return false;
     }
 
+    // MoraPaper
+    public net.minemora.MoraPaper.PlayerDistanceData nearestPlayerData = new net.minemora.MoraPaper.PlayerDistanceData();
+
+    public @Nullable Player getNearestPlayerNew() {
+        if(nearestPlayerData.uuid != null) {
+            org.bukkit.entity.Player bukkitPlayer = org.bukkit.Bukkit.getPlayer(nearestPlayerData.uuid);
+            if(bukkitPlayer != null) {
+                return ((org.bukkit.craftbukkit.entity.CraftPlayer)bukkitPlayer).getHandle();
+            }
+            else {
+                nearestPlayerData.uuid = null;
+            }
+        }
+        return null;
+    }
+
     @Override
     public void checkDespawn() {
         if (this.level().getDifficulty() == Difficulty.PEACEFUL && this.shouldDespawnInPeaceful()) {
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
-            Entity nearestPlayer = this.level().findNearbyPlayer(this, -1.0, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper - Affects Spawning API
+            Player nearestPlayer = this.getNearestPlayerNew(); // MoraPaper - Optimize get nearest player
             if (nearestPlayer != null) {
                 // Paper start - Configurable despawn distances
+                // MoraPaper Start - Use our cached nearest player distance
                 final io.papermc.paper.configuration.WorldConfiguration.Entities.Spawning.DespawnRangePair despawnRangePair = this.level().paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory());
                 final io.papermc.paper.configuration.type.DespawnRange.Shape shape = this.level().paperConfig().entities.spawning.despawnRangeShape;
-                final double dy = Math.abs(nearestPlayer.getY() - this.getY());
-                final double dySqr = Mth.square(dy);
-                final double dxSqr = Mth.square(nearestPlayer.getX() - this.getX());
-                final double dzSqr = Mth.square(nearestPlayer.getZ() - this.getZ());
-                final double distanceSquared = dxSqr + dzSqr + dySqr;
+                final double dy = nearestPlayerData.dy;
+                final double dySqr = nearestPlayerData.dySqr;
+                final double dxSqr = nearestPlayerData.dxSqr;
+                final double dzSqr = nearestPlayerData.dzSqr;
+                final double distanceSquared = nearestPlayerData.distanceSqr;
+                // MoraPaper End
                 // Despawn if hard/soft limit is exceeded
                 if (despawnRangePair.hard().shouldDespawn(shape, dxSqr, dySqr, dzSqr, dy) && this.removeWhenFarAway(distanceSquared)) {
                     this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
diff --git a/net/minecraft/world/entity/ai/goal/GoalSelector.java b/net/minecraft/world/entity/ai/goal/GoalSelector.java
index 859b859d29b637200cf7c9a0bd52d9f712413e3d..b77c5b992fb09518f3da352af0a0a424b1e40b10 100644
--- a/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -38,7 +38,7 @@ public class GoalSelector {
     // Paper start - EAR 2
     public boolean inactiveTick() {
         this.curRate++;
-        return this.curRate % 3 == 0; // TODO newGoalRate was already unused in 1.20.4, check if this is correct
+        return this.curRate % 40 == 0; // MoraPaper - Increase curRate from 3 to 40
     }
 
     public boolean hasTasks() {
diff --git a/net/minecraft/world/entity/monster/Monster.java b/net/minecraft/world/entity/monster/Monster.java
index 5ef9566b16a4d0300ee45a993c46e734db156416..6562b362f62f362b6faf9f9d1c7d0b6576a217f7 100644
--- a/net/minecraft/world/entity/monster/Monster.java
+++ b/net/minecraft/world/entity/monster/Monster.java
@@ -40,6 +40,7 @@ public abstract class Monster extends PathfinderMob implements Enemy {
 
     @Override
     public void aiStep() {
+        if (nearestPlayerData.distanceSqr > distanceSqrToDisableAi) return;
         this.updateSwingTime();
         this.updateNoActionTime();
         super.aiStep();
diff --git a/net/minecraft/world/entity/npc/Villager.java b/net/minecraft/world/entity/npc/Villager.java
index 43f16df230f87a43e249a58fc10ef2da517f22ee..313d6cb65bc04b5ba480b9f94a76fbf08591e468 100644
--- a/net/minecraft/world/entity/npc/Villager.java
+++ b/net/minecraft/world/entity/npc/Villager.java
@@ -293,7 +293,12 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         // Paper start - EAR 2
         this.customServerAiStep(level, false);
     }
-    protected void customServerAiStep(ServerLevel level, final boolean inactive) {
+    protected void customServerAiStep(ServerLevel level, boolean inactive) {
+        // MoraSpigot - Mark inactive if the player is too far away
+        if(nearestPlayerData.distanceSqr > distanceSqrToDisableAi) {
+            inactive = true;
+        }
+
         // Paper end - EAR 2
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("villagerBrain");
diff --git a/net/minecraft/world/entity/player/Inventory.java b/net/minecraft/world/entity/player/Inventory.java
index a6bb436dc80daf6901dc027a6011ead4b3ed27e2..90d93e4a9835589c913fe56605cdf5d3c4abed83 100644
--- a/net/minecraft/world/entity/player/Inventory.java
+++ b/net/minecraft/world/entity/player/Inventory.java
@@ -33,6 +33,7 @@ public class Inventory implements Container, Nameable {
     public static final int SLOT_BODY_ARMOR = 41;
     public static final int SLOT_SADDLE = 42;
     public static final int NOT_FOUND_INDEX = -1;
+
     public static final Int2ObjectMap<EquipmentSlot> EQUIPMENT_SLOT_MAPPING = new Int2ObjectArrayMap<>(
         Map.of(
             EquipmentSlot.FEET.getIndex(36),
@@ -51,6 +52,7 @@ public class Inventory implements Container, Nameable {
             EquipmentSlot.SADDLE
         )
     );
+
     private final NonNullList<ItemStack> items = NonNullList.withSize(36, ItemStack.EMPTY);
     private int selected;
     public final Player player;
diff --git a/net/minecraft/world/entity/projectile/Snowball.java b/net/minecraft/world/entity/projectile/Snowball.java
index 677b4b681f9c2c09a8ae3cfdec72102265547a7b..1fb6779bd950a8b5e4de0395c80672a0672aa94b 100644
--- a/net/minecraft/world/entity/projectile/Snowball.java
+++ b/net/minecraft/world/entity/projectile/Snowball.java
@@ -64,4 +64,13 @@ public class Snowball extends ThrowableItemProjectile {
             this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.HIT); // CraftBukkit - add Bukkit remove cause
         }
     }
+
+    // MoraPaper start - Prevent Snowball Lag Machine
+    @Override
+    public void tick() {
+        super.tick();
+        if (this.tickCount >= 8) discard();
+    }
+    // MoraPaper end - Prevent Snowball Lag Machine
+
 }
diff --git a/net/minecraft/world/entity/projectile/ThrownEgg.java b/net/minecraft/world/entity/projectile/ThrownEgg.java
index 73ec34b43f3fb2aa3edc3f1cb48a923d1fa32036..9b4fe0316e71f0dd4740390e53ce534aebfa2d3a 100644
--- a/net/minecraft/world/entity/projectile/ThrownEgg.java
+++ b/net/minecraft/world/entity/projectile/ThrownEgg.java
@@ -128,4 +128,13 @@ public class ThrownEgg extends ThrowableItemProjectile {
     public Item getDefaultItem() {
         return Items.EGG;
     }
+
+    // MoraPaper start - Prevent Egg Lag Machine
+    @Override
+    public void tick() {
+        super.tick();
+        if (this.tickCount >= 8) discard();
+    }
+    // MoraPaper end - Prevent Egg Lag Machine
+
 }
diff --git a/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java b/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
index 090b19752fbfc856d9fbf118510afc6cda2b9989..71486d7a2c7b7e775db283f937c9ffce1268d4db 100644
--- a/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
@@ -367,6 +367,13 @@ public class NewMinecartBehavior extends MinecartBehavior {
         if (this.minecart.getFirstPassenger() instanceof ServerPlayer serverPlayer) {
             Vec3 lastClientMoveIntent = serverPlayer.getLastClientMoveIntent();
             if (lastClientMoveIntent.lengthSqr() > 0.0) {
+                // MoraPaper Start - Steer minecart event
+                final org.bukkit.event.player.PlayerSteerMinecartEvent event = new org.bukkit.event.player.PlayerSteerMinecartEvent(serverPlayer.getBukkitEntity(), (org.bukkit.entity.Minecart) this.minecart.getBukkitEntity());
+                event.callEvent();
+
+                if (event.isCancelled()) return speed;
+                // MoraPaper End
+
                 Vec3 vec3 = lastClientMoveIntent.normalize();
                 double d = speed.horizontalDistanceSqr();
                 if (vec3.lengthSqr() > 0.0 && d < 0.01) {
diff --git a/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java b/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java
index 0d09b0809e7b224538cf5cfac9e36ec5ba10b709..b953d6d8c66917eaa3ee5b580ca2aad71440dd59 100644
--- a/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java
@@ -162,6 +162,17 @@ public class OldMinecartBehavior extends MinecartBehavior {
         Vec3 lastClientMoveIntent;
         if (this.minecart.getFirstPassenger() instanceof ServerPlayer serverPlayer) {
             lastClientMoveIntent = serverPlayer.getLastClientMoveIntent();
+
+            // MoraPaper Start - Steer minecart event
+            if (lastClientMoveIntent.x != 0 || lastClientMoveIntent.y != 0 || lastClientMoveIntent.z != 0) {
+                final org.bukkit.event.player.PlayerSteerMinecartEvent event = new org.bukkit.event.player.PlayerSteerMinecartEvent(serverPlayer.getBukkitEntity(), (org.bukkit.entity.Minecart) this.minecart.getBukkitEntity());
+                event.callEvent();
+
+                if (event.isCancelled()) {
+                    lastClientMoveIntent = net.minecraft.world.phys.Vec3.ZERO;
+                }
+            }
+            // MoraPaper End
         } else {
             lastClientMoveIntent = Vec3.ZERO;
         }
diff --git a/net/minecraft/world/level/entity/EntityTickList.java b/net/minecraft/world/level/entity/EntityTickList.java
index 423779a2b690f387a4f0bd07b97b50e0baefda76..33cdab242a3d58c6cbe4ede3497f1864f05bcf7e 100644
--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -11,6 +11,9 @@ import net.minecraft.world.entity.Entity;
 public class EntityTickList {
     private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
 
+    // MoraPaper - async list to use entities from other threads
+    private final java.util.concurrent.ConcurrentLinkedQueue<net.minecraft.world.entity.Entity> asyncEntities = new java.util.concurrent.ConcurrentLinkedQueue<>();
+
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
     }
@@ -18,11 +21,13 @@ public class EntityTickList {
     public void add(Entity entity) {
         this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - rewrite chunk system
+        this.asyncEntities.add(entity); // MoraPaper - async list to use entities from other threads
     }
 
     public void remove(Entity entity) {
         this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - rewrite chunk system
+        this.asyncEntities.remove(entity); // MoraPaper - async list to use entities from other threads
     }
 
     public boolean contains(Entity entity) {
@@ -43,4 +48,10 @@ public class EntityTickList {
         }
         // Paper end - rewrite chunk system
     }
+
+    // MoraPaper - async list to use entities from other threads
+    public java.util.concurrent.ConcurrentLinkedQueue<Entity> getEntitiesAsync() {
+        return asyncEntities;
+    }
+
 }
