From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tehin <62246450+Tehin@users.noreply.github.com>
Date: Wed, 2 Apr 2025 22:23:25 -0500
Subject: [PATCH] Minemora Patch


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index f473999938840562b1007a789600342e5796a123..29ed24a2518e97aff8c5c1f259b4d30226abaeca 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -67,6 +67,9 @@ public final class ChunkHolderManager {
     public static final int ENTITY_TICKING_TICKET_LEVEL = ChunkLevel.ENTITY_TICKING_LEVEL;
     public static final int MAX_TICKET_LEVEL = ChunkLevel.MAX_LEVEL; // inclusive
 
+    // MoraPaper - Limit chunk unloads per tick
+    private static final int MAX_CHUNK_UNLOADS_PER_TICK = 180;
+
     public static final TicketType UNLOAD_COOLDOWN = ChunkSystemTicketType.create("chunk_system:unload_cooldown", null, 5L * 20L);
 
     private static final long NO_TIMEOUT_MARKER = Long.MIN_VALUE;
@@ -1173,7 +1176,9 @@ public final class ChunkHolderManager {
         // We do need to process updates here so that any addTicket that is synchronised before this call does not go missed.
         this.processTicketUpdates();
 
-        final int toUnloadCount = Math.max(50, (int)(unloadCountTentative * 0.05));
+        // MoraPaper - Limit chunk unload to prevent RAM overuse
+        final int toUnloadCount = Math.max(50,Math.min(MAX_CHUNK_UNLOADS_PER_TICK, (int) (unloadCountTentative * 0.05)));
+
         int processedCount = 0;
 
         for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
diff --git a/net/minecraft/network/chat/OutgoingChatMessage.java b/net/minecraft/network/chat/OutgoingChatMessage.java
index 4635182c73f28f63ba84982cb6bcb422221b738e..eb40e9b8051c7e159146104383a747d1c3c26566 100644
--- a/net/minecraft/network/chat/OutgoingChatMessage.java
+++ b/net/minecraft/network/chat/OutgoingChatMessage.java
@@ -26,6 +26,9 @@ public interface OutgoingChatMessage {
             this.sendToPlayer(player, filtered, boundType, null);
         }
         public void sendToPlayer(ServerPlayer player, boolean filtered, ChatType.Bound boundType, @javax.annotation.Nullable Component unsigned) {
+            // MoraPaper
+            if (player.chatDisabled) return;
+
             player.connection.sendDisguisedChatMessage(unsigned != null ? unsigned : this.content, boundType);
             // Paper end
         }
@@ -43,6 +46,9 @@ public interface OutgoingChatMessage {
             this.sendToPlayer(player, filtered, boundType, null);
         }
         public void sendToPlayer(ServerPlayer player, boolean filtered, ChatType.Bound boundType, @javax.annotation.Nullable Component unsigned) {
+            // MoraPaper
+            if (player.chatDisabled) return;
+
             // Paper end
             PlayerChatMessage playerChatMessage = this.message.filter(filtered);
             playerChatMessage = unsigned != null ? playerChatMessage.withUnsignedContent(unsigned) : playerChatMessage; // Paper
diff --git a/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java b/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java
index d13d67a3925f96a2a27159d303e8c19478971bd7..6b4dde35e530c964aa605f0f64e00c6a24ceb474 100644
--- a/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java
+++ b/net/minecraft/network/protocol/game/ClientboundPlayerInfoUpdatePacket.java
@@ -228,7 +228,7 @@ public class ClientboundPlayerInfoUpdatePacket implements Packet<ClientGamePacke
                 player.getUUID(),
                 player.getGameProfile(),
                 listed, // Paper - Add Listing API for Player
-                player.connection.latency(),
+                player.connection == null ? player.fakePing : player.connection.latency(),
                 player.gameMode(),
                 player.getTabListDisplayName(),
                 player.isModelPartShown(PlayerModelPart.HAT),
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index f1373fd5fdebb9f4600ba7f32a5df6188de3a0e9..d49597655c93e86d4dc44eb09fdb118f3b9d3b1f 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -1656,18 +1656,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
         this.server.getScheduler().mainThreadHeartbeat(); // CraftBukkit
         // Paper start - Folia scheduler API
-        ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
-        getAllLevels().forEach(level -> {
-            for (final net.minecraft.world.entity.Entity entity : level.getEntities().getAll()) {
-                if (entity.isRemoved()) {
-                    continue;
-                }
-                final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
-                if (bukkit != null) {
-                    bukkit.taskScheduler.executeTick();
-                }
-            }
-        });
+        // ((io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler) org.bukkit.Bukkit.getGlobalRegionScheduler()).tick();
+        // getAllLevels().forEach(level -> {
+        //     for (final net.minecraft.world.entity.Entity entity : level.getEntities().getAll()) {
+        //         if (entity.isRemoved()) {
+        //             continue;
+        //         }
+        //         final org.bukkit.craftbukkit.entity.CraftEntity bukkit = entity.getBukkitEntityRaw();
+        //         if (bukkit != null) {
+        //             bukkit.taskScheduler.executeTick();
+        //         }
+        //     }
+        // });
         // Paper end - Folia scheduler API
         io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.CALLBACK_MANAGER.handleQueue(this.tickCount); // Paper
         profilerFiller.push("commandFunctions");
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index 0d8aefe8c886eaa4c33cbab53b0ad1c016f0531f..05c0d2b308b43b8b50eb126509607df3394f561e 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1176,11 +1176,16 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
+                // MoraPaper - Iterate in the set itself not by creating a completely new arraylist
+                final java.util.Iterator<net.minecraft.server.network.ServerPlayerConnection> seenByIterator = this.seenBy.iterator();
+
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                while (seenByIterator.hasNext()) {
+                    final ServerPlayerConnection conn = seenByIterator.next();
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
-                        this.removePlayer(player);
+                        seenByIterator.remove();
+                        this.forceRemovePlayerPairing(player);
                     }
                 }
             }
@@ -1278,6 +1283,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
         }
 
+        // MoraSpigot - Remove the player without removing or checking for the seenBy, to prevent CME
+        // when the player is removed while in a loop
+        public void forceRemovePlayerPairing(ServerPlayer player) {
+            this.serverEntity.removePairing(player);
+        }
+
         public void updatePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (player != this.entity) {
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 59e8a5e1b35c81883c9b1ca00c6e55d77584d8cc..08cc07b2ba69f1a75df5081dcc6904215ec79aef 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -79,9 +79,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
     private final ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<net.minecraft.world.level.chunk.LevelChunk> fullChunks = new ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<>();
+
     public int getFullChunksCount() {
         return this.fullChunks.size();
     }
+
     long chunkFutureAwaitCounter;
     // Paper end
     // Paper start - rewrite chunk system
@@ -102,7 +104,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     private ChunkAccess syncLoad(final int chunkX, final int chunkZ, final ChunkStatus toStatus) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler();
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler();
         final CompletableFuture<ChunkAccess> completable = new CompletableFuture<>();
         chunkTaskScheduler.scheduleChunkLoad(
             chunkX, chunkZ, toStatus, true, ca.spottedleaf.concurrentutil.util.Priority.BLOCKING,
@@ -130,9 +132,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         return ret;
     }
 
-    private ChunkAccess getChunkFallback(final int chunkX, final int chunkZ, final ChunkStatus toStatus,
-                                         final boolean load) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler();
+    private ChunkAccess getChunkFallback(
+        final int chunkX, final int chunkZ, final ChunkStatus toStatus,
+        final boolean load
+    ) {
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler();
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager chunkHolderManager = chunkTaskScheduler.chunkHolderManager;
 
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder currentChunk = chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ));
@@ -154,16 +158,18 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         return load ? this.syncLoad(chunkX, chunkZ, toStatus) : null;
     }
+
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration optimisations
     private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom shuffleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(0L);
+
     private void iterateTickingChunksFaster() {
         final ServerLevel world = this.level;
         final int randomTickSpeed = world.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
 
         // TODO check on update: impl of forEachBlockTickingChunk will only iterate ENTITY ticking chunks!
         // TODO check on update: consumer just runs tickChunk
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getEntityTickingChunks();
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) world).moonrise$getEntityTickingChunks();
 
         // note: we can use the backing array here because:
         // 1. we do not care about new additions
@@ -177,7 +183,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
             // call mid-tick tasks for chunk system
             if ((i & 7) == 0) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.level.getServer()).moonrise$executeMidTickTasks();
+                ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer) this.level.getServer()).moonrise$executeMidTickTasks();
                 continue;
             }
         }
@@ -207,7 +213,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         try {
             FileUtil.createDirectoriesSafe(path);
         } catch (IOException var15) {
-            LOGGER.error("Failed to create dimension data storage directory", (Throwable)var15);
+            LOGGER.error("Failed to create dimension data storage directory", (Throwable) var15);
         }
 
         this.dataStorage = new DimensionDataStorage(new SavedData.Context(level), path, fixerUpper, level.registryAccess());
@@ -343,7 +349,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             return ret;
         }
 
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler()
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler()
             .chunkHolderManager.getChunkHolder(chunkX, chunkZ);
         if (holder == null) {
             return ret;
@@ -369,7 +375,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             chunkFutureMainThread = CompletableFuture.<CompletableFuture<ChunkResult<ChunkAccess>>>supplyAsync(
                     () -> this.getChunkFutureMainThread(x, z, chunkStatus, requireChunk), this.mainThreadProcessor
                 )
-                .thenCompose(future -> (CompletionStage<ChunkResult<ChunkAccess>>)future);
+                .thenCompose(future -> (CompletionStage<ChunkResult<ChunkAccess>>) future);
         }
 
         return chunkFutureMainThread;
@@ -380,7 +386,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, x, z, "Scheduling chunk load off-main");
 
         final int minLevel = ChunkLevel.byStatus(chunkStatus);
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(x, z);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(x, z);
 
         final boolean needsFullScheduling = chunkStatus == ChunkStatus.FULL && (chunkHolder == null || !chunkHolder.getChunkStatus().isOrAfter(FullChunkStatus.FULL));
 
@@ -400,7 +406,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 }
             };
 
-            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().scheduleChunkLoad(
+            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().scheduleChunkLoad(
                 x, z, chunkStatus, true,
                 ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
                 complete
@@ -423,7 +429,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     @Override
     public LightChunk getChunkForLighting(int chunkX, int chunkZ) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkX, chunkZ);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkX, chunkZ);
         if (newChunkHolder == null) {
             return null;
         }
@@ -441,12 +447,12 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     public boolean runDistanceManagerUpdates() {
-        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
+        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
     }
 
     public boolean isPositionTicking(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
         return newChunkHolder != null && newChunkHolder.isTickingReady();
         // Paper end - rewrite chunk system
     }
@@ -466,7 +472,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         // CraftBukkit end
         // Paper - rewrite chunk system
         this.dataStorage.close();
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.close(save, true); // Paper - rewrite chunk system
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.close(save, true); // Paper - rewrite chunk system
     }
 
     // CraftBukkit start - modelled on below
@@ -495,7 +501,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         this.runDistanceManagerUpdates();
         profilerFiller.popPush("chunks");
         if (tickChunks) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
+            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
             this.tickChunks();
             this.chunkMap.tick();
         }
@@ -538,7 +544,23 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         profiler.pop();
     }
 
+    // MoraPaper - Only do chunk mob spawning each 5 ticks instead of every tick
+    private final static int SPAWN_UPDATE_INTERVAL = 5;
+
+    // MoraPaper - The last time we ticked mob spawning
+    private int ticksSinceLastSpawnUpdate = 0;
+
     private void tickChunks(ProfilerFiller profiler, long timeInhabited) {
+        ticksSinceLastSpawnUpdate++;
+
+        // MoraPaper - Tick without the mob spawning between the interval
+        if (ticksSinceLastSpawnUpdate <= SPAWN_UPDATE_INTERVAL) {
+            iterateTickingChunksFaster();
+            return;
+        }
+
+        ticksSinceLastSpawnUpdate = 0;
+
         profiler.popPush("naturalSpawnCount");
         int naturalSpawnChunkCount = this.distanceManager.getNaturalSpawnChunkCount();
         // Paper start - Optional per player mob spawns
@@ -591,7 +613,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             profiler.popPush("shuffleSpawningChunks");
             // Paper start - chunk tick iteration optimisation
             this.shuffleRandom.setSeed(this.level.random.nextLong());
-            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
+            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns)
+                Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
             // Paper end - chunk tick iteration optimisation
             profiler.popPush("tickSpawningChunks");
 
@@ -619,12 +642,21 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         }
 
         if (!spawnCategories.isEmpty()) {
-            if (this.level.getWorldBorder().isWithinBounds(pos)) { // Paper - rewrite chunk system
+            if (this.level.getWorldBorder().isWithinBounds(pos) && !isInNoNaturalSpawnRadius(pos)) { // Paper - rewrite chunk system
                 NaturalSpawner.spawnForChunk(this.level, chunk, spawnState, spawnCategories);
             }
         }
     }
 
+    // MoraPaper Start - Limit natural spawn radius
+    public static boolean isInNoNaturalSpawnRadius(ChunkPos pos) {
+        int radius = 10; //TODO from config
+        int x = pos.x;
+        int z = pos.z;
+        return x >= -radius && x < radius && z >= -radius && z < radius;
+    }
+    // MoraPaper End
+
     private void getFullChunk(long chunkPos, Consumer<LevelChunk> fullChunkGetter) {
         // Paper start - rewrite chunk system
         // note: bypass currentlyLoaded from getChunkNow
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index d50d2928ad9f8b34a14621b1fe5c188547e04bd1..41fdce164af8c82b9fd37bf129ce714480f690ce 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -175,7 +175,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList<>(); // MoraPaper - Use CopyOnWriteArrayList for safe async loops
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
@@ -562,6 +562,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
     // Paper end - chunk tick iteration
 
+    // MoraPaper - Get async entities from our tick list (calculated in another thread)
+    public java.util.concurrent.ConcurrentLinkedQueue<Entity> getEntitiesAsync() {
+        return entityTickList.getEntitiesAsync();
+    }
+
     public ServerLevel(
         MinecraftServer server,
         Executor dispatcher,
@@ -671,6 +676,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.chunkDataController = new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.ChunkDataController((ServerLevel)(Object)this, this.chunkTaskScheduler);
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
+        // MoraPaper
+        net.minemora.MoraPaper.startNearestPlayerUpdater(this);
     }
 
     // Paper start
@@ -832,9 +839,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         if (this.tickTime) {
             long l = this.levelData.getGameTime() + 1L;
             this.serverLevelData.setGameTime(l);
-            Profiler.get().push("scheduledFunctions");
             this.serverLevelData.getScheduledEvents().tick(this.server, l);
-            Profiler.get().pop();
             if (this.serverLevelData.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
                 this.setDayTime(this.levelData.getDayTime() + 1L);
             }
@@ -913,8 +918,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         ChunkPos pos = chunk.getPos();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("iceandsnow");
 
         if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
         for (int i = 0; i < randomTickSpeed; i++) {
@@ -924,12 +927,9 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         }
         } // Paper - Option to disable ice and snow
 
-        profilerFiller.popPush("tickBlocks");
         if (randomTickSpeed > 0) {
             this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
         }
-
-        profilerFiller.pop();
     }
 
     public void tickThunder(LevelChunk chunk) {
@@ -937,15 +937,14 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         boolean isRaining = this.isRaining();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        ProfilerFiller profilerFiller = Profiler.get();
-        profilerFiller.push("thunder");
         if (!this.paperConfig().environment.disableThunder && isRaining && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
             BlockPos blockPos = this.findLightningTargetAround(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             if (this.isRainingAt(blockPos)) {
                 DifficultyInstance currentDifficultyAt = this.getCurrentDifficultyAt(blockPos);
                 boolean flag = this.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)
                     && this.random.nextDouble() < currentDifficultyAt.getEffectiveDifficulty() * this.paperConfig().entities.spawning.skeletonHorseThunderSpawnChance.or(0.01) // Paper - Configurable spawn chances for skeleton horses
-                    && !this.getBlockState(blockPos.below()).is(Blocks.LIGHTNING_ROD);
+                    && !this.getBlockState(blockPos.below()).is(Blocks.LIGHTNING_ROD)
+                    && !ServerChunkCache.isInNoNaturalSpawnRadius(pos);
                 if (flag) {
                     SkeletonHorse skeletonHorse = EntityType.SKELETON_HORSE.create(this, EntitySpawnReason.EVENT);
                     if (skeletonHorse != null) {
@@ -964,8 +963,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 }
             }
         }
-
-        profilerFiller.pop();
     }
 
     @VisibleForTesting
@@ -1259,17 +1256,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             }
             // Paper end - log detailed entity tick information
         entity.setOldPosAndRot();
-        ProfilerFiller profilerFiller = Profiler.get();
         entity.tickCount++;
         entity.totalEntityAge++; // Paper - age-like counter for all entities
-        profilerFiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(entity.getType()).toString());
-        profilerFiller.incrementCounter("tickNonPassenger");
         final boolean isActive = io.papermc.paper.entity.activation.ActivationRange.checkIfActive(entity); // Paper - EAR 2
         if (isActive) { // Paper - EAR 2
         entity.tick();
         entity.postTick(); // CraftBukkit
         } else {entity.inactiveTick();} // Paper - EAR 2
-        profilerFiller.pop();
 
         for (Entity entity1 : entity.getPassengers()) {
             this.tickPassenger(entity, entity1, isActive); // Paper - EAR 2
@@ -1290,9 +1283,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             passengerEntity.setOldPosAndRot();
             passengerEntity.tickCount++;
             passengerEntity.totalEntityAge++; // Paper - age-like counter for all entities
-            ProfilerFiller profilerFiller = Profiler.get();
-            profilerFiller.push(() -> BuiltInRegistries.ENTITY_TYPE.getKey(passengerEntity.getType()).toString());
-            profilerFiller.incrementCounter("tickPassenger");
             // Paper start - EAR 2
             if (isActive) {
             passengerEntity.rideTick();
@@ -1304,7 +1294,6 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 ridingEntity.positionRider(passengerEntity);
             }
             // Paper end - EAR 2
-            profilerFiller.pop();
 
             for (Entity entity : passengerEntity.getPassengers()) {
                 this.tickPassenger(passengerEntity, entity, isActive); // Paper - EAR 2
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index 6457f41fe7882d8c532e16851400c37a67e8cd52..197a73cafb820372db1d968eb1c78a966cf9a32c 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -212,6 +212,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
     public final ServerPlayerGameMode gameMode;
     private final PlayerAdvancements advancements;
     private final ServerStatsCounter stats;
+    public int fakePing;
     private float lastRecordedHealthAndAbsorption = Float.MIN_VALUE;
     private int lastRecordedFoodLevel = Integer.MIN_VALUE;
     private int lastRecordedAirLevel = Integer.MIN_VALUE;
@@ -478,6 +479,23 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.maxHealthCache = this.getMaxHealth();
     }
 
+    // MoraPaper - optimized constructor for NPCs
+    public ServerPlayer(MinecraftServer server, ServerLevel level, GameProfile gameProfile) {
+        super(level, level.getSharedSpawnPos(), level.getSharedSpawnAngle(), gameProfile);
+        this.textFilter = server.createTextFilterForPlayer(this);
+        this.gameMode = server.createGameModeForPlayer(this);
+        this.server = server;
+        this.object = null;
+        // CraftBukkit start
+        this.displayName = this.getScoreboardName();
+        this.adventure$displayName = net.kyori.adventure.text.Component.text(this.getScoreboardName()); // Paper
+        this.bukkitPickUpLoot = true;
+        this.maxHealthCache = this.getMaxHealth();
+        this.recipeBook = null;
+        this.stats = null;
+        this.advancements = null;
+    }
+
     @Override
     public BlockPos adjustSpawnLocation(ServerLevel level, BlockPos pos) {
         AABB aabb = this.getDimensions(Pose.STANDING).makeBoundingBox(Vec3.ZERO);
@@ -2165,7 +2183,12 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.sendSystemMessage(mesage, false);
     }
 
+    // MoraPaper - Completely disable chat
+    public boolean chatDisabled = false;
+
     public void sendSystemMessage(Component message, boolean overlay) {
+        if (chatDisabled) return;
+
         if (this.acceptsSystemMessages(overlay)) {
             this.connection
                 .send(
@@ -2193,6 +2216,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.sendChatMessage(message, filtered, boundType, null);
     }
     public void sendChatMessage(OutgoingChatMessage message, boolean filtered, ChatType.Bound boundType, @Nullable Component unsigned) {
+        // MoraPaper
+        if (chatDisabled) return;
+
         // Paper end
         if (this.acceptsChatMessages()) {
             message.sendToPlayer(this, filtered, boundType, unsigned); // Paper
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 5e921c490814be31fc2843327c0e2cc76bda6620..dcd94778b207b3283034ae24f89612f8d5f73e98 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -2588,6 +2588,10 @@ public class ServerGamePacketListenerImpl
             return;
         }
         // CraftBukkit end
+
+        // MoraPaper
+        if (player.chatDisabled) return;
+
         // Paper start - Ensure that client receives chat packets in the same order that we add into the message signature cache
         synchronized (this.messageSignatureCache) {
         this.send(
diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index 73ba442b9d39bc021cd5eb6c1c0f98aed94a5a02..8b1fa093e02f32e6fdd266212bf547f5b7b264cf 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -486,8 +486,13 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         this.setSpeed(0.0F);
     }
 
+    // MoraPaper
+    public static int distanceSqrToDisableAi = 400;
+
     @Override
     public void aiStep() {
+        if(nearestPlayerData.distanceSqr > distanceSqrToDisableAi) return;
+
         super.aiStep();
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("looting");
@@ -678,21 +683,39 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         return false;
     }
 
+    // MoraPaper
+    public net.minemora.MoraPaper.PlayerDistanceData nearestPlayerData = new net.minemora.MoraPaper.PlayerDistanceData();
+
+    public @Nullable Player getNearestPlayerNew() {
+        if(nearestPlayerData.uuid != null) {
+            org.bukkit.entity.Player bukkitPlayer = org.bukkit.Bukkit.getPlayer(nearestPlayerData.uuid);
+            if(bukkitPlayer != null) {
+                return ((org.bukkit.craftbukkit.entity.CraftPlayer)bukkitPlayer).getHandle();
+            }
+            else {
+                nearestPlayerData.uuid = null;
+            }
+        }
+        return null;
+    }
+
     @Override
     public void checkDespawn() {
         if (this.level().getDifficulty() == Difficulty.PEACEFUL && this.shouldDespawnInPeaceful()) {
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
-            Entity nearestPlayer = this.level().findNearbyPlayer(this, -1.0, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper - Affects Spawning API
+            Player nearestPlayer = this.getNearestPlayerNew(); // MoraPaper - Optimize get nearest player
             if (nearestPlayer != null) {
                 // Paper start - Configurable despawn distances
+                // MoraPaper Start - Use our cached nearest player distance
                 final io.papermc.paper.configuration.WorldConfiguration.Entities.Spawning.DespawnRangePair despawnRangePair = this.level().paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory());
                 final io.papermc.paper.configuration.type.DespawnRange.Shape shape = this.level().paperConfig().entities.spawning.despawnRangeShape;
-                final double dy = Math.abs(nearestPlayer.getY() - this.getY());
-                final double dySqr = Mth.square(dy);
-                final double dxSqr = Mth.square(nearestPlayer.getX() - this.getX());
-                final double dzSqr = Mth.square(nearestPlayer.getZ() - this.getZ());
-                final double distanceSquared = dxSqr + dzSqr + dySqr;
+                final double dy = nearestPlayerData.dy;
+                final double dySqr = nearestPlayerData.dySqr;
+                final double dxSqr = nearestPlayerData.dxSqr;
+                final double dzSqr = nearestPlayerData.dzSqr;
+                final double distanceSquared = nearestPlayerData.distanceSqr;
+                // MoraPaper End
                 // Despawn if hard/soft limit is exceeded
                 if (despawnRangePair.hard().shouldDespawn(shape, dxSqr, dySqr, dzSqr, dy) && this.removeWhenFarAway(distanceSquared)) {
                     this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
diff --git a/net/minecraft/world/entity/ai/goal/GoalSelector.java b/net/minecraft/world/entity/ai/goal/GoalSelector.java
index a927c2790c8ab9ccaa7161b970e10b0b44817dd8..22d369538f27d055d2adee72536869ee2804adf0 100644
--- a/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -40,7 +40,7 @@ public class GoalSelector {
     // Paper start - EAR 2
     public boolean inactiveTick() {
         this.curRate++;
-        return this.curRate % 3 == 0; // TODO newGoalRate was already unused in 1.20.4, check if this is correct
+        return this.curRate % 40 == 0; // MoraPaper - Increase curRate from 3 to 40
     }
 
     public boolean hasTasks() {
diff --git a/net/minecraft/world/entity/monster/Monster.java b/net/minecraft/world/entity/monster/Monster.java
index 5ef9566b16a4d0300ee45a993c46e734db156416..6562b362f62f362b6faf9f9d1c7d0b6576a217f7 100644
--- a/net/minecraft/world/entity/monster/Monster.java
+++ b/net/minecraft/world/entity/monster/Monster.java
@@ -40,6 +40,7 @@ public abstract class Monster extends PathfinderMob implements Enemy {
 
     @Override
     public void aiStep() {
+        if (nearestPlayerData.distanceSqr > distanceSqrToDisableAi) return;
         this.updateSwingTime();
         this.updateNoActionTime();
         super.aiStep();
diff --git a/net/minecraft/world/entity/npc/Villager.java b/net/minecraft/world/entity/npc/Villager.java
index e0e0d2ea7fc60e3142c675404d152eca60263240..6d90ff8363613f5d4be4b5d2aee2b0effb72d02d 100644
--- a/net/minecraft/world/entity/npc/Villager.java
+++ b/net/minecraft/world/entity/npc/Villager.java
@@ -292,7 +292,12 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         // Paper start - EAR 2
         this.customServerAiStep(level, false);
     }
-    protected void customServerAiStep(ServerLevel level, final boolean inactive) {
+    protected void customServerAiStep(ServerLevel level, boolean inactive) {
+        // MoraSpigot - Mark inactive if the player is too far away
+        if(nearestPlayerData.distanceSqr > distanceSqrToDisableAi) {
+            inactive = true;
+        }
+
         // Paper end - EAR 2
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("villagerBrain");
diff --git a/net/minecraft/world/level/entity/EntityTickList.java b/net/minecraft/world/level/entity/EntityTickList.java
index 423779a2b690f387a4f0bd07b97b50e0baefda76..33cdab242a3d58c6cbe4ede3497f1864f05bcf7e 100644
--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -11,6 +11,9 @@ import net.minecraft.world.entity.Entity;
 public class EntityTickList {
     private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
 
+    // MoraPaper - async list to use entities from other threads
+    private final java.util.concurrent.ConcurrentLinkedQueue<net.minecraft.world.entity.Entity> asyncEntities = new java.util.concurrent.ConcurrentLinkedQueue<>();
+
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
     }
@@ -18,11 +21,13 @@ public class EntityTickList {
     public void add(Entity entity) {
         this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - rewrite chunk system
+        this.asyncEntities.add(entity); // MoraPaper - async list to use entities from other threads
     }
 
     public void remove(Entity entity) {
         this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - rewrite chunk system
+        this.asyncEntities.remove(entity); // MoraPaper - async list to use entities from other threads
     }
 
     public boolean contains(Entity entity) {
@@ -43,4 +48,10 @@ public class EntityTickList {
         }
         // Paper end - rewrite chunk system
     }
+
+    // MoraPaper - async list to use entities from other threads
+    public java.util.concurrent.ConcurrentLinkedQueue<Entity> getEntitiesAsync() {
+        return asyncEntities;
+    }
+
 }
