From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tehin <62246450+Tehin@users.noreply.github.com>
Date: Wed, 2 Apr 2025 22:23:25 -0500
Subject: [PATCH] Minemora Patch


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index f473999938840562b1007a789600342e5796a123..29ed24a2518e97aff8c5c1f259b4d30226abaeca 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -67,6 +67,9 @@ public final class ChunkHolderManager {
     public static final int ENTITY_TICKING_TICKET_LEVEL = ChunkLevel.ENTITY_TICKING_LEVEL;
     public static final int MAX_TICKET_LEVEL = ChunkLevel.MAX_LEVEL; // inclusive
 
+    // MoraPaper - Limit chunk unloads per tick
+    private static final int MAX_CHUNK_UNLOADS_PER_TICK = 180;
+
     public static final TicketType UNLOAD_COOLDOWN = ChunkSystemTicketType.create("chunk_system:unload_cooldown", null, 5L * 20L);
 
     private static final long NO_TIMEOUT_MARKER = Long.MIN_VALUE;
@@ -1173,7 +1176,9 @@ public final class ChunkHolderManager {
         // We do need to process updates here so that any addTicket that is synchronised before this call does not go missed.
         this.processTicketUpdates();
 
-        final int toUnloadCount = Math.max(50, (int)(unloadCountTentative * 0.05));
+        // MoraPaper - Limit chunk unload to prevent RAM overuse
+        final int toUnloadCount = Math.max(50,Math.min(MAX_CHUNK_UNLOADS_PER_TICK, (int) (unloadCountTentative * 0.05)));
+
         int processedCount = 0;
 
         for (final ChunkUnloadQueue.SectionToUnload sectionRef : unloadSectionsForRegion) {
diff --git a/net/minecraft/network/chat/OutgoingChatMessage.java b/net/minecraft/network/chat/OutgoingChatMessage.java
index 4635182c73f28f63ba84982cb6bcb422221b738e..eb40e9b8051c7e159146104383a747d1c3c26566 100644
--- a/net/minecraft/network/chat/OutgoingChatMessage.java
+++ b/net/minecraft/network/chat/OutgoingChatMessage.java
@@ -26,6 +26,9 @@ public interface OutgoingChatMessage {
             this.sendToPlayer(player, filtered, boundType, null);
         }
         public void sendToPlayer(ServerPlayer player, boolean filtered, ChatType.Bound boundType, @javax.annotation.Nullable Component unsigned) {
+            // MoraPaper
+            if (player.chatDisabled) return;
+
             player.connection.sendDisguisedChatMessage(unsigned != null ? unsigned : this.content, boundType);
             // Paper end
         }
@@ -43,6 +46,9 @@ public interface OutgoingChatMessage {
             this.sendToPlayer(player, filtered, boundType, null);
         }
         public void sendToPlayer(ServerPlayer player, boolean filtered, ChatType.Bound boundType, @javax.annotation.Nullable Component unsigned) {
+            // MoraPaper
+            if (player.chatDisabled) return;
+
             // Paper end
             PlayerChatMessage playerChatMessage = this.message.filter(filtered);
             playerChatMessage = unsigned != null ? playerChatMessage.withUnsignedContent(unsigned) : playerChatMessage; // Paper
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index 0d8aefe8c886eaa4c33cbab53b0ad1c016f0531f..05c0d2b308b43b8b50eb126509607df3394f561e 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1176,11 +1176,16 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
+                // MoraPaper - Iterate in the set itself not by creating a completely new arraylist
+                final java.util.Iterator<net.minecraft.server.network.ServerPlayerConnection> seenByIterator = this.seenBy.iterator();
+
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                while (seenByIterator.hasNext()) {
+                    final ServerPlayerConnection conn = seenByIterator.next();
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
-                        this.removePlayer(player);
+                        seenByIterator.remove();
+                        this.forceRemovePlayerPairing(player);
                     }
                 }
             }
@@ -1278,6 +1283,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
         }
 
+        // MoraSpigot - Remove the player without removing or checking for the seenBy, to prevent CME
+        // when the player is removed while in a loop
+        public void forceRemovePlayerPairing(ServerPlayer player) {
+            this.serverEntity.removePairing(player);
+        }
+
         public void updatePlayer(ServerPlayer player) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (player != this.entity) {
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 59e8a5e1b35c81883c9b1ca00c6e55d77584d8cc..86f61ad65097cbf37c217e6b60342ac0b2d5eb13 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -79,9 +79,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
     private final ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<net.minecraft.world.level.chunk.LevelChunk> fullChunks = new ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<>();
+
     public int getFullChunksCount() {
         return this.fullChunks.size();
     }
+
     long chunkFutureAwaitCounter;
     // Paper end
     // Paper start - rewrite chunk system
@@ -102,7 +104,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     private ChunkAccess syncLoad(final int chunkX, final int chunkZ, final ChunkStatus toStatus) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler();
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler();
         final CompletableFuture<ChunkAccess> completable = new CompletableFuture<>();
         chunkTaskScheduler.scheduleChunkLoad(
             chunkX, chunkZ, toStatus, true, ca.spottedleaf.concurrentutil.util.Priority.BLOCKING,
@@ -130,9 +132,11 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         return ret;
     }
 
-    private ChunkAccess getChunkFallback(final int chunkX, final int chunkZ, final ChunkStatus toStatus,
-                                         final boolean load) {
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler();
+    private ChunkAccess getChunkFallback(
+        final int chunkX, final int chunkZ, final ChunkStatus toStatus,
+        final boolean load
+    ) {
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler chunkTaskScheduler = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler();
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager chunkHolderManager = chunkTaskScheduler.chunkHolderManager;
 
         final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder currentChunk = chunkHolderManager.getChunkHolder(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(chunkX, chunkZ));
@@ -154,16 +158,18 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
         return load ? this.syncLoad(chunkX, chunkZ, toStatus) : null;
     }
+
     // Paper end - rewrite chunk system
     // Paper start - chunk tick iteration optimisations
     private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom shuffleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(0L);
+
     private void iterateTickingChunksFaster() {
         final ServerLevel world = this.level;
         final int randomTickSpeed = world.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
 
         // TODO check on update: impl of forEachBlockTickingChunk will only iterate ENTITY ticking chunks!
         // TODO check on update: consumer just runs tickChunk
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getEntityTickingChunks();
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) world).moonrise$getEntityTickingChunks();
 
         // note: we can use the backing array here because:
         // 1. we do not care about new additions
@@ -177,7 +183,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
             // call mid-tick tasks for chunk system
             if ((i & 7) == 0) {
-                ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.level.getServer()).moonrise$executeMidTickTasks();
+                ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer) this.level.getServer()).moonrise$executeMidTickTasks();
                 continue;
             }
         }
@@ -207,7 +213,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         try {
             FileUtil.createDirectoriesSafe(path);
         } catch (IOException var15) {
-            LOGGER.error("Failed to create dimension data storage directory", (Throwable)var15);
+            LOGGER.error("Failed to create dimension data storage directory", (Throwable) var15);
         }
 
         this.dataStorage = new DimensionDataStorage(new SavedData.Context(level), path, fixerUpper, level.registryAccess());
@@ -343,7 +349,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             return ret;
         }
 
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler()
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder holder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler()
             .chunkHolderManager.getChunkHolder(chunkX, chunkZ);
         if (holder == null) {
             return ret;
@@ -369,7 +375,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             chunkFutureMainThread = CompletableFuture.<CompletableFuture<ChunkResult<ChunkAccess>>>supplyAsync(
                     () -> this.getChunkFutureMainThread(x, z, chunkStatus, requireChunk), this.mainThreadProcessor
                 )
-                .thenCompose(future -> (CompletionStage<ChunkResult<ChunkAccess>>)future);
+                .thenCompose(future -> (CompletionStage<ChunkResult<ChunkAccess>>) future);
         }
 
         return chunkFutureMainThread;
@@ -380,7 +386,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, x, z, "Scheduling chunk load off-main");
 
         final int minLevel = ChunkLevel.byStatus(chunkStatus);
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(x, z);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder chunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(x, z);
 
         final boolean needsFullScheduling = chunkStatus == ChunkStatus.FULL && (chunkHolder == null || !chunkHolder.getChunkStatus().isOrAfter(FullChunkStatus.FULL));
 
@@ -400,7 +406,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 }
             };
 
-            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().scheduleChunkLoad(
+            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().scheduleChunkLoad(
                 x, z, chunkStatus, true,
                 ca.spottedleaf.concurrentutil.util.Priority.HIGHER,
                 complete
@@ -423,7 +429,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     @Override
     public LightChunk getChunkForLighting(int chunkX, int chunkZ) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkX, chunkZ);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkX, chunkZ);
         if (newChunkHolder == null) {
             return null;
         }
@@ -441,12 +447,12 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
 
     public boolean runDistanceManagerUpdates() {
-        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
+        return ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates(); // Paper - rewrite chunk system
     }
 
     public boolean isPositionTicking(long chunkPos) {
         // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
+        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
         return newChunkHolder != null && newChunkHolder.isTickingReady();
         // Paper end - rewrite chunk system
     }
@@ -466,7 +472,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         // CraftBukkit end
         // Paper - rewrite chunk system
         this.dataStorage.close();
-        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.close(save, true); // Paper - rewrite chunk system
+        ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.close(save, true); // Paper - rewrite chunk system
     }
 
     // CraftBukkit start - modelled on below
@@ -495,7 +501,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         this.runDistanceManagerUpdates();
         profilerFiller.popPush("chunks");
         if (tickChunks) {
-            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
+            ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel) this.level).moonrise$getPlayerChunkLoader().tick(); // Paper - rewrite chunk system
             this.tickChunks();
             this.chunkMap.tick();
         }
@@ -538,7 +544,23 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         profiler.pop();
     }
 
+    // MoraPaper - Only do chunk mob spawning each 5 ticks instead of every tick
+    private final static int SPAWN_UPDATE_INTERVAL = 5;
+
+    // MoraPaper - The last time we ticked mob spawning
+    private int ticksSinceLastSpawnUpdate = 0;
+
     private void tickChunks(ProfilerFiller profiler, long timeInhabited) {
+        ticksSinceLastSpawnUpdate++;
+
+        // MoraPaper - Tick without the mob spawning between the interval
+        if (ticksSinceLastSpawnUpdate <= SPAWN_UPDATE_INTERVAL) {
+            iterateTickingChunksFaster();
+            return;
+        }
+
+        ticksSinceLastSpawnUpdate = 0;
+
         profiler.popPush("naturalSpawnCount");
         int naturalSpawnChunkCount = this.distanceManager.getNaturalSpawnChunkCount();
         // Paper start - Optional per player mob spawns
@@ -591,7 +613,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             profiler.popPush("shuffleSpawningChunks");
             // Paper start - chunk tick iteration optimisation
             this.shuffleRandom.setSeed(this.level.random.nextLong());
-            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
+            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns)
+                Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
             // Paper end - chunk tick iteration optimisation
             profiler.popPush("tickSpawningChunks");
 
@@ -619,12 +642,21 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         }
 
         if (!spawnCategories.isEmpty()) {
-            if (this.level.getWorldBorder().isWithinBounds(pos)) { // Paper - rewrite chunk system
+            if (this.level.getWorldBorder().isWithinBounds(pos) && !isInNoNaturalSpawnRadius(pos)) { // Paper - rewrite chunk system
                 NaturalSpawner.spawnForChunk(this.level, chunk, spawnState, spawnCategories);
             }
         }
     }
 
+    // MoraPaper Start - Limit natural spawn radius
+    private boolean isInNoNaturalSpawnRadius(ChunkPos pos) {
+        int radius = 10; //TODO from config
+        int x = pos.x;
+        int z = pos.z;
+        return x >= -radius && x < radius && z >= -radius && z < radius;
+    }
+    // MoraPaper End
+
     private void getFullChunk(long chunkPos, Consumer<LevelChunk> fullChunkGetter) {
         // Paper start - rewrite chunk system
         // note: bypass currentlyLoaded from getChunkNow
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index d50d2928ad9f8b34a14621b1fe5c188547e04bd1..eab6ecaa7561779a52c1fdb19fa0a9ec2be9aecc 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -175,7 +175,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int EMPTY_TIME_NO_TICK = 300;
     private static final int MAX_SCHEDULED_TICKS_PER_TICK = 65536;
-    final List<ServerPlayer> players = Lists.newArrayList();
+    final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList<>(); // MoraPaper - Use CopyOnWriteArrayList for safe async loops
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
@@ -562,6 +562,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
     // Paper end - chunk tick iteration
 
+    // MoraPaper - Get async entities from our tick list (calculated in another thread)
+    public java.util.concurrent.ConcurrentLinkedQueue<Entity> getEntitiesAsync() {
+        return entityTickList.getEntitiesAsync();
+    }
+
     public ServerLevel(
         MinecraftServer server,
         Executor dispatcher,
@@ -671,6 +676,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.chunkDataController = new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.ChunkDataController((ServerLevel)(Object)this, this.chunkTaskScheduler);
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
+        // MoraPaper
+        net.minemora.MoraPaper.startNearestPlayerUpdater(this);
     }
 
     // Paper start
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index 6457f41fe7882d8c532e16851400c37a67e8cd52..2b869da876c89a934541663b8cda775e14d6d99e 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -2165,7 +2165,12 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.sendSystemMessage(mesage, false);
     }
 
+    // MoraPaper - Completely disable chat
+    public boolean chatDisabled = false;
+
     public void sendSystemMessage(Component message, boolean overlay) {
+        if (chatDisabled) return;
+
         if (this.acceptsSystemMessages(overlay)) {
             this.connection
                 .send(
@@ -2193,6 +2198,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.sendChatMessage(message, filtered, boundType, null);
     }
     public void sendChatMessage(OutgoingChatMessage message, boolean filtered, ChatType.Bound boundType, @Nullable Component unsigned) {
+        // MoraPaper
+        if (chatDisabled) return;
+
         // Paper end
         if (this.acceptsChatMessages()) {
             message.sendToPlayer(this, filtered, boundType, unsigned); // Paper
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 5e921c490814be31fc2843327c0e2cc76bda6620..dcd94778b207b3283034ae24f89612f8d5f73e98 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -2588,6 +2588,10 @@ public class ServerGamePacketListenerImpl
             return;
         }
         // CraftBukkit end
+
+        // MoraPaper
+        if (player.chatDisabled) return;
+
         // Paper start - Ensure that client receives chat packets in the same order that we add into the message signature cache
         synchronized (this.messageSignatureCache) {
         this.send(
diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index 73ba442b9d39bc021cd5eb6c1c0f98aed94a5a02..8b1fa093e02f32e6fdd266212bf547f5b7b264cf 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -486,8 +486,13 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         this.setSpeed(0.0F);
     }
 
+    // MoraPaper
+    public static int distanceSqrToDisableAi = 400;
+
     @Override
     public void aiStep() {
+        if(nearestPlayerData.distanceSqr > distanceSqrToDisableAi) return;
+
         super.aiStep();
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("looting");
@@ -678,21 +683,39 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         return false;
     }
 
+    // MoraPaper
+    public net.minemora.MoraPaper.PlayerDistanceData nearestPlayerData = new net.minemora.MoraPaper.PlayerDistanceData();
+
+    public @Nullable Player getNearestPlayerNew() {
+        if(nearestPlayerData.uuid != null) {
+            org.bukkit.entity.Player bukkitPlayer = org.bukkit.Bukkit.getPlayer(nearestPlayerData.uuid);
+            if(bukkitPlayer != null) {
+                return ((org.bukkit.craftbukkit.entity.CraftPlayer)bukkitPlayer).getHandle();
+            }
+            else {
+                nearestPlayerData.uuid = null;
+            }
+        }
+        return null;
+    }
+
     @Override
     public void checkDespawn() {
         if (this.level().getDifficulty() == Difficulty.PEACEFUL && this.shouldDespawnInPeaceful()) {
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
-            Entity nearestPlayer = this.level().findNearbyPlayer(this, -1.0, EntitySelector.PLAYER_AFFECTS_SPAWNING); // Paper - Affects Spawning API
+            Player nearestPlayer = this.getNearestPlayerNew(); // MoraPaper - Optimize get nearest player
             if (nearestPlayer != null) {
                 // Paper start - Configurable despawn distances
+                // MoraPaper Start - Use our cached nearest player distance
                 final io.papermc.paper.configuration.WorldConfiguration.Entities.Spawning.DespawnRangePair despawnRangePair = this.level().paperConfig().entities.spawning.despawnRanges.get(this.getType().getCategory());
                 final io.papermc.paper.configuration.type.DespawnRange.Shape shape = this.level().paperConfig().entities.spawning.despawnRangeShape;
-                final double dy = Math.abs(nearestPlayer.getY() - this.getY());
-                final double dySqr = Mth.square(dy);
-                final double dxSqr = Mth.square(nearestPlayer.getX() - this.getX());
-                final double dzSqr = Mth.square(nearestPlayer.getZ() - this.getZ());
-                final double distanceSquared = dxSqr + dzSqr + dySqr;
+                final double dy = nearestPlayerData.dy;
+                final double dySqr = nearestPlayerData.dySqr;
+                final double dxSqr = nearestPlayerData.dxSqr;
+                final double dzSqr = nearestPlayerData.dzSqr;
+                final double distanceSquared = nearestPlayerData.distanceSqr;
+                // MoraPaper End
                 // Despawn if hard/soft limit is exceeded
                 if (despawnRangePair.hard().shouldDespawn(shape, dxSqr, dySqr, dzSqr, dy) && this.removeWhenFarAway(distanceSquared)) {
                     this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
diff --git a/net/minecraft/world/entity/ai/goal/GoalSelector.java b/net/minecraft/world/entity/ai/goal/GoalSelector.java
index a927c2790c8ab9ccaa7161b970e10b0b44817dd8..22d369538f27d055d2adee72536869ee2804adf0 100644
--- a/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -40,7 +40,7 @@ public class GoalSelector {
     // Paper start - EAR 2
     public boolean inactiveTick() {
         this.curRate++;
-        return this.curRate % 3 == 0; // TODO newGoalRate was already unused in 1.20.4, check if this is correct
+        return this.curRate % 40 == 0; // MoraPaper - Increase curRate from 3 to 40
     }
 
     public boolean hasTasks() {
diff --git a/net/minecraft/world/level/entity/EntityTickList.java b/net/minecraft/world/level/entity/EntityTickList.java
index 423779a2b690f387a4f0bd07b97b50e0baefda76..33cdab242a3d58c6cbe4ede3497f1864f05bcf7e 100644
--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -11,6 +11,9 @@ import net.minecraft.world.entity.Entity;
 public class EntityTickList {
     private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
 
+    // MoraPaper - async list to use entities from other threads
+    private final java.util.concurrent.ConcurrentLinkedQueue<net.minecraft.world.entity.Entity> asyncEntities = new java.util.concurrent.ConcurrentLinkedQueue<>();
+
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
     }
@@ -18,11 +21,13 @@ public class EntityTickList {
     public void add(Entity entity) {
         this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - rewrite chunk system
+        this.asyncEntities.add(entity); // MoraPaper - async list to use entities from other threads
     }
 
     public void remove(Entity entity) {
         this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - rewrite chunk system
+        this.asyncEntities.remove(entity); // MoraPaper - async list to use entities from other threads
     }
 
     public boolean contains(Entity entity) {
@@ -43,4 +48,10 @@ public class EntityTickList {
         }
         // Paper end - rewrite chunk system
     }
+
+    // MoraPaper - async list to use entities from other threads
+    public java.util.concurrent.ConcurrentLinkedQueue<Entity> getEntitiesAsync() {
+        return asyncEntities;
+    }
+
 }
